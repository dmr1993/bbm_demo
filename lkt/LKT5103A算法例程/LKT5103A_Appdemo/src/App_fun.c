#include "DEF_Type.h"
#include "lk_api.h"
#include "string.h"
#include "math.h"

#define ADDR_OF_DES_KEY   0x0100 												//√‹‘øµÿ÷∑
#define ADDR_OF_DATA      0x0000												// ˝æ›µÿ÷∑

/***************************************************************************************************************
Des_encrypt ,DES ªÚTripDES º”√‹‘ÀÀ„
LenOfKey----±ÿ–ÎŒ™ 8 ªÚ 16 
LenOfIn ----±ÿ–ÎŒ™8 µƒ’˚ ˝±∂
***************************************************************************************************************/
void Des_encrypt(u8 LenOfKey, u8 LenOfIn, u8  * pKey, u8  * pIn, u8   * pOut )
{
	 u16 i;
	 u16 blk_num;
	 
	 blk_num = LenOfIn / 8;

	 LK_DesSetKey(LenOfKey, pKey);
	 
	 for(i=0;i<blk_num;i++)
	 {
	  LK_DesEncode(pIn, pOut);
	  pIn  +=8;
	  pOut +=8;
	 }
}

/***************************************************************************************************************
Des_decrypt ,DES ªÚTripDES Ω‚√‹‘ÀÀ„
LenOfKey ----±ÿ–ÎŒ™ 8 ªÚ 16 
LenOfIn -----±ÿ–ÎŒ™8 µƒ’˚ ˝±∂
***************************************************************************************************************/
void Des_decrypt(u8 LenOfKey, u8 LenOfIn, u8  * pKey, u8  * pIn, u8  * pOut )
{
	 u16 i;
	 u16 blk_num;
	 
	 blk_num = LenOfIn / 8;

	 LK_DesSetKey(LenOfKey, pKey);
	 
	 for(i=0;i<blk_num;i++)
	 {
	  LK_DesDecode(pIn, pOut);
	  pIn  +=8;
	  pOut +=8;
	 }
}
/*************************************************************************************************************
	Aes_encrypt ,AES º”√‹‘ÀÀ„
	LenOfKey ---------±ÿ–ÎŒ™ 16 or 24 or 32
	LenOfIn ----------±ÿ–ÎŒ™16 µƒ’˚ ˝±∂
*************************************************************************************************************/
void Aes_encrypt(u8 LenOfKey, u8 LenOfIn, u8 * pKey, u8 * pIn, u8 * pOut )
{
	 u16 i;
	 u16 blk_num;
	 u8 roundkey[240]; // –Ë“™Œ™AES ‘ÀÀ„…Í«Î240 ◊÷Ω⁄µƒ roundkey ø’º‰
	 
	 blk_num = LenOfIn / 16;

	 LK_AesSetKeyEnc(LenOfKey,pKey,roundkey) ;
	 
	 for(i=0;i<blk_num;i++)
	 {
	  LK_AesEncode(pIn, pOut);
	  pIn  +=16;
	  pOut +=16;
	 }
}

/*********************************************************************************************************
	Aes_decrypt ,AES Ω‚√‹‘ÀÀ„
	LenOfKey ----------±ÿ–ÎŒ™ 16 or 24 or 32
	LenOfIn -----------±ÿ–ÎŒ™16 µƒ’˚ ˝±∂
**********************************************************************************************************/
void Aes_decrypt(u8 LenOfKey, u8 LenOfIn, u8 * pKey, u8 * pIn, u8 * pOut )
{
	 u16 i;
	 u16 blk_num;
	 u8 roundkey[240]; // –Ë“™Œ™AES ‘ÀÀ„…Í«Î240 ◊÷Ω⁄µƒ roundkey ø’º‰
	 
	 blk_num = LenOfIn / 16;

	 LK_AesSetKeyDec(LenOfKey,pKey,roundkey);
	 
	 for(i=0;i<blk_num;i++)
	 {
	  LK_AesDecode(pIn, pOut);
	  pIn  +=16;
	  pOut +=16;
	 }
}

void GPIO_IN(u8 GPIO_Pin)
{  
  int i=GPIO_Pin-1;	
	GPIO->GPIODIR &= ~(1<<i);//0 « ‰»Î
}
u8 READ_GPIO(u8 GPIO_Pin)
{  
  int i=GPIO_Pin-1;	
  return ((u8)(GPIO->GPIODATA>>i)&0x01);
}

void GPIO_OUT(u8 GPIO_Pin)
{
  int i=GPIO_Pin-1;  	
	GPIO->GPIODIR |= (1<<i);	//1 « ‰≥ˆ
}

void GPIO_SetBits(u8 GPIO_Pin)
{  
  int i=GPIO_Pin-1;  		
	GPIO->GPIODATA |= (1<<i); // ¿≠∏ﬂ		
}

void GPIO_ResetBits(u8 GPIO_Pin)
{
  int i=GPIO_Pin-1;
	GPIO->GPIODATA &= ~(1<<i);// ¿≠µÕ
}

/********************************************************************************************************
	Hash_Digest : º∆À„HASH
	hashType =0 -------±Ì æ SHA-1 À„∑®, 
	hashType =1 -------±Ì æ SHA-256 À„∑®
*********************************************************************************************************/
void Hash_Digest(u8 hashType, u16 LenOfMsg, u8 * pMsg, u8 * pDigest)
{
 	LK_HashInit(hashType);
	LK_HashLastUpdate(hashType , pMsg, LenOfMsg );
	LK_HashGetDigest(hashType, pDigest );
}















/**************************************************************************************************************
∫Ø ˝√˚≥∆£∫Communication_Test
∫Ø ˝≤Œ ˝£∫u8  *in -------  ‰»Î ˝æ›
          u8  *out-------  ‰≥ˆ ˝æ›
          u8 len--------------  ‰»Î ˝æ›≥§∂»
∫Ø ˝π¶ƒ‹£∫≤‚ ‘Õ®—∂ «∑Ò’˝≥£
∫Ø ˝ ‰≥ˆ£∫Ω´ ‰»Î ˝æ›»°∑¥∫Û  ‰
***************************************************************************************************************/
void Communication_Test(u8  *in,u8 *out,u8 len)
{
  u8 i;
    
  for(i=0;i < len;i++)
   out[i]= ~in[i]; 
			   	
}




/***************************************************************************************************************
∫Ø ˝√˚≥∆: Write_Key
∫Ø ˝≤Œ ˝£∫u8  *buf --- –¥»Î√‹‘øµƒ÷µ  £® ∏Ò Ω £∫√‹‘ø≥§∂» + √‹‘ø÷µ £©
∫Ø ˝π¶ƒ‹£∫–¥»Î√‹‘ø∫
∫Ø ˝ ‰≥ˆ£∫Œﬁ

◊¢√˜£∫¥À–¥»Î√‹‘ø∫Ø ˝ ø…π© ∂‘±»»œ÷§°¢≤Œ ˝±£ª§°¢À„∑®“∆÷≤ –¥√‹‘ø π”√

÷∏¡Ó∏Ò Ω æ¿˝£∫ 8008 0000 12 02 10 000102030405060708090A0B0C0D0E0F
****************************************************************************************************************/
void Write_Key(u8 *buf)
{  
  u16 key_addr;
  key_addr = ADDR_OF_DES_KEY;
  LK_WriteNvm(key_addr,buf,buf[0]+1);
  return;
}









/************************************************ ∂‘±»»œ÷§∑Ω∞∏ ************************************************/
/***************************************************************************************************************
∫Ø ˝√˚≥∆£∫Contrast_Authentication 
∫Ø ˝≤Œ ˝£∫u8  *pIn-------------  ‰»Î ˝æ›
					u8  *pIn-------------  ‰≥ˆ ˝æ›

∫Ø ˝π¶ƒ‹£∫ ∂‘±»»œ÷§∫Ø ˝
∫Ø ˝ ‰≥ˆ£∫ 8◊÷Ω⁄ÀÊª˙ ˝ + 8◊÷Ω⁄µƒº”√‹Ω·π˚

÷∏¡Ó∏Ò Ω æ¿˝ £∫8008 0000 09 03 1122334455667788
***************************************************************************************************************/
int Contrast_Authentication(u8 *pIn,u8 *pOut)
{
	 u8 i=0;
	 u8 RandBuf[0x20];
	 u8 CompBuf[0x20];
	 u8 KeyBuf[0x20];

	 memmove(CompBuf,pIn,0x08);      														// Ω´º”√‹ ˝æ› ¥Ê∑≈µΩ CompBuf  ˝◊È÷–
   LK_GetRandom( RandBuf,0x08);    														// ªÒ»°8◊÷Ω⁄ÀÊª˙ ˝
	 memmove( pOut,RandBuf,0x08);    														// pOut µÿ÷∑ø™ º¥Ê»Î 8◊÷Ω⁄ÀÊª˙ ˝
   for(i=0;i < 8;i++)
   {
        CompBuf[i] ^=RandBuf[i]; 															//ÀÊª˙ ˝”Î¥´»Î ˝æ›“ÏªÚ≤Ÿ◊˜
	 }	
 
	 
  
	LK_ReadNvm(ADDR_OF_DES_KEY,KeyBuf,0x11);										//NVM«¯÷–∂¡»°√‹‘ø //»Áπ˚KEY µƒ≥§∂»¥ÌŒÛ,‘ÚŒﬁ∑®ÕÍ≥…º”√‹‘ÀÀ„ 
  if ((KeyBuf[0] != 8) && (KeyBuf[0] != 16 ) )
  {  
			return 0;
  }
  Des_encrypt(KeyBuf[0],8,KeyBuf+1,CompBuf,pOut+8);  					// pOut+8 µÿ÷∑ø™ º ¥Ê∑≈º”√‹µƒ ˝æ›

  return 1;

}












/************************************************** ≤Œ ˝±£ª§∑Ω∞∏ ***********************************************/
/****************************************************************************************************************
∫Ø ˝√˚≥∆£∫Write_Important_Data
∫Ø ˝≤Œ ˝£∫u8  *pIn -------- ‰»Î ˝æ›
∫Ø ˝π¶ƒ‹£∫∑¢––Ω◊∂Œ–¥»Î÷ÿ“™ ˝æ›
∫Ø ˝ ‰≥ˆ£∫Œﬁ

÷∏¡Ó∏Ò Ω æ¿˝: 8008 0000 09 04 0102030405060708
****************************************************************************************************************/
void Write_Important_Data(u8  *pIn)
{
	u16 Important_Data_Addr;
	
  Important_Data_Addr = ADDR_OF_DATA ;
  LK_WriteNvm(Important_Data_Addr,pIn,8);  														//πÃ∂®¥´»Î≤Œ ˝ 8◊÷Ω⁄ 
}



/***************************************************************************************************************
∫Ø ˝√˚≥∆£∫Read_Important_Data
∫Ø ˝≤Œ ˝£∫u8  *pIn --------- ‰»Î ˝æ›
					u8  *pOut--------- ‰≥ˆ ˝æ›

∫Ø ˝π¶ƒ‹£∫ π”√Ω◊∂Œ÷ÿ“™≤Œ ˝ ‰≥ˆ∫Ø ˝
∫Ø ˝ ‰≥ˆ£∫8◊÷Ω⁄ ÀÊª˙ ˝ + 8◊÷Ω⁄µƒ√‹Œƒ

÷∏¡Ó∏Ò Ω æ¿˝£∫8008 0000 09 05 1122334455667788
****************************************************************************************************************/
int Read_Important_Data(u8  *pIn,u8  *pOut)
{
	u8 i=0;
	u8 RandBuf_1[0x20];
	u8 RandBuf_2[0x20];
	u8 ParaBuf[0x20];
	u8 KeyBuf[0x20];
  memmove(RandBuf_1,pIn,0x08); 																		  //Ω´MCU ∑¢¿¥µƒ8◊÷Ω⁄ÀÊª˙ ˝¥Ê¥¢‘⁄ RandBuf_1÷–
	
	LK_GetRandom(RandBuf_2,0x08);   																  // ªÒ»°8◊÷Ω⁄ÀÊª˙ ˝
  memmove( pOut,RandBuf_2,0x08);                                    // pOut µÿ÷∑ø™ º¥Ê»Î 8◊÷Ω⁄ÀÊª˙ ˝
	
  for(i=0;i < 8;i++)
  {
        RandBuf_2[i] ^=RandBuf_1[i]; 																//ÀÊª˙ ˝”Î¥´»ÎÀÊª˙ ˝◊ˆ“ÏªÚ≤Ÿ◊˜
	}	
  
  LK_ReadNvm((u16)ADDR_OF_DATA,ParaBuf,8);   										    // ∂¡»° ¥´»Îµƒ8 ◊÷Ω⁄÷ÿ“™≤Œ ˝
	
	for(i=0;i < 8;i++)
  {
        ParaBuf[i] ^=RandBuf_2[i]; 																	//ÀÊª˙ ˝”Î ◊‹“™≤Œ ˝◊ˆ“ÏªÚ
	}	

	
	LK_ReadNvm(ADDR_OF_DES_KEY,KeyBuf,0x11);													//NVM«¯÷–∂¡»°√‹‘ø //»Áπ˚KEY µƒ≥§∂»¥ÌŒÛ,‘ÚŒﬁ∑®ÕÍ≥…º”√‹‘ÀÀ„ 
  if ((KeyBuf[0] != 8) && (KeyBuf[0] != 16 ) )
  {  
			return 0;
  }
  Des_encrypt(KeyBuf[0],8,KeyBuf+1,ParaBuf,pOut+8);  								// pOut+8 µÿ÷∑ø™ º ¥Ê∑≈º”√‹µƒ ˝æ›
	
	return 1;
	
}

// CBC  µœ÷∑Ω Ω ≤Œ ˝±£ª§ ‰≥ˆ












/************************************************ À„∑®“∆÷≤∑Ω∞∏*************************************************/
/**************************************************************************************************************

∫Ø ˝√˚≥∆£∫Algorithm_Transplantation
∫Ø ˝≤Œ ˝£∫u8  *pIn --------- ‰»Î ˝æ›
					u8  *pOut -------- ‰≥ˆ ˝æ›

∫Ø ˝π¶ƒ‹£∫À„∑®“∆÷≤¿˝≥Ã
∫Ø ˝ ‰≥ˆ£∫À„∑®‘ÀÀ„Ω·π˚

◊¢√˜£∫ ¥À“∆÷≤∫Ø ˝Ωˆπ©≤Œøº

   x          0<=x <2
y= x*x+1       2<= x <6
   sqrt(x+1)  6<=x<10
   1/(x+1)    10<x <=20
	 

÷∏¡Ó∏Ò Ω æ¿˝£∫8008 0000 02 06 xx
***************************************************************************************************************/
int Algorithm_Transplantation(u8 *pIn,u8 *pOut)
{

	  float num=0.0;
    if( pIn[0]>=0.0 && pIn[0]<2)
		{
				num=pIn[0];
		}
	  else if( pIn[0]>=2 && pIn[0]<6 )
		{
				num=pIn[0]*pIn[0]+1;
		}
	  else if( pIn[0]>=6 && pIn[0]<10)
		{
			  num=sqrt(pIn[0]+1);
		}
		else if( pIn[0]>=10 )
		{
				num= 1.0/(pIn[0]+1);
		}
		
		memmove(pOut,&num,0x04);
		
		return 4;
}


















