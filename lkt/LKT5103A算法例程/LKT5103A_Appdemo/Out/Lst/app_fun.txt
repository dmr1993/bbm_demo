; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --debug -c --asm --interleave -o..\out\bin\app_fun.o --asm_dir=..\Out\Lst\ --list_dir=..\Out\Lst\ --depend=..\out\bin\app_fun.d --cpu=Cortex-M0 --apcs=interwork -O3 -I..\head -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.0\CMSIS\Include -IC:\Keil_v5\ARM\Inc\LinkSafe --omf_browse=..\out\bin\app_fun.crf ..\src\App_fun.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  Des_encrypt PROC
;;;13     ***************************************************************************************************************/
;;;14     void Des_encrypt(u8 LenOfKey, u8 LenOfIn, u8  * pKey, u8  * pIn, u8   * pOut )
000000  b5f8              PUSH     {r3-r7,lr}
;;;15     {
;;;16     	 u16 i;
;;;17     	 u16 blk_num;
;;;18     	 
;;;19     	 blk_num = LenOfIn / 8;
000002  08cf              LSRS     r7,r1,#3
000004  461d              MOV      r5,r3                 ;15
;;;20     
;;;21     	 LK_DesSetKey(LenOfKey, pKey);
000006  4611              MOV      r1,r2
000008  9e06              LDR      r6,[sp,#0x18]
00000a  f7fffffe          BL       LK_DesSetKey
;;;22     	 
;;;23     	 for(i=0;i<blk_num;i++)
00000e  2400              MOVS     r4,#0
000010  e007              B        |L1.34|
                  |L1.18|
;;;24     	 {
;;;25     	  LK_DesEncode(pIn, pOut);
000012  4631              MOV      r1,r6
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       LK_DesEncode
00001a  1c64              ADDS     r4,r4,#1
00001c  3508              ADDS     r5,r5,#8              ;23
00001e  b2a4              UXTH     r4,r4                 ;23
000020  3608              ADDS     r6,r6,#8              ;23
                  |L1.34|
000022  42bc              CMP      r4,r7                 ;23
000024  d3f5              BCC      |L1.18|
;;;26     	  pIn  +=8;
;;;27     	  pOut +=8;
;;;28     	 }
;;;29     }
000026  bdf8              POP      {r3-r7,pc}
;;;30     
                          ENDP

                  Des_decrypt PROC
;;;35     ***************************************************************************************************************/
;;;36     void Des_decrypt(u8 LenOfKey, u8 LenOfIn, u8  * pKey, u8  * pIn, u8  * pOut )
000028  b5f8              PUSH     {r3-r7,lr}
;;;37     {
;;;38     	 u16 i;
;;;39     	 u16 blk_num;
;;;40     	 
;;;41     	 blk_num = LenOfIn / 8;
00002a  08cf              LSRS     r7,r1,#3
00002c  461d              MOV      r5,r3                 ;37
;;;42     
;;;43     	 LK_DesSetKey(LenOfKey, pKey);
00002e  4611              MOV      r1,r2
000030  9e06              LDR      r6,[sp,#0x18]
000032  f7fffffe          BL       LK_DesSetKey
;;;44     	 
;;;45     	 for(i=0;i<blk_num;i++)
000036  2400              MOVS     r4,#0
000038  e007              B        |L1.74|
                  |L1.58|
;;;46     	 {
;;;47     	  LK_DesDecode(pIn, pOut);
00003a  4631              MOV      r1,r6
00003c  4628              MOV      r0,r5
00003e  f7fffffe          BL       LK_DesDecode
000042  1c64              ADDS     r4,r4,#1
000044  3508              ADDS     r5,r5,#8              ;45
000046  b2a4              UXTH     r4,r4                 ;45
000048  3608              ADDS     r6,r6,#8              ;45
                  |L1.74|
00004a  42bc              CMP      r4,r7                 ;45
00004c  d3f5              BCC      |L1.58|
;;;48     	  pIn  +=8;
;;;49     	  pOut +=8;
;;;50     	 }
;;;51     }
00004e  bdf8              POP      {r3-r7,pc}
;;;52     /*************************************************************************************************************
                          ENDP

                  Aes_encrypt PROC
;;;56     *************************************************************************************************************/
;;;57     void Aes_encrypt(u8 LenOfKey, u8 LenOfIn, u8 * pKey, u8 * pIn, u8 * pOut )
000050  b5f0              PUSH     {r4-r7,lr}
;;;58     {
000052  461d              MOV      r5,r3
000054  b0bd              SUB      sp,sp,#0xf4
000056  4613              MOV      r3,r2
;;;59     	 u16 i;
;;;60     	 u16 blk_num;
;;;61     	 u8 roundkey[240]; // 需要为AES 运算申请240 字节的 roundkey 空间
;;;62     	 
;;;63     	 blk_num = LenOfIn / 16;
000058  090f              LSRS     r7,r1,#4
;;;64     
;;;65     	 LK_AesSetKeyEnc(LenOfKey,pKey,roundkey) ;
00005a  466a              MOV      r2,sp
00005c  4619              MOV      r1,r3
00005e  9e42              LDR      r6,[sp,#0x108]
000060  f7fffffe          BL       LK_AesSetKeyEnc
;;;66     	 
;;;67     	 for(i=0;i<blk_num;i++)
000064  2400              MOVS     r4,#0
000066  e007              B        |L1.120|
                  |L1.104|
;;;68     	 {
;;;69     	  LK_AesEncode(pIn, pOut);
000068  4631              MOV      r1,r6
00006a  4628              MOV      r0,r5
00006c  f7fffffe          BL       LK_AesEncode
000070  1c64              ADDS     r4,r4,#1
000072  3510              ADDS     r5,r5,#0x10           ;67
000074  b2a4              UXTH     r4,r4                 ;67
000076  3610              ADDS     r6,r6,#0x10           ;67
                  |L1.120|
000078  42bc              CMP      r4,r7                 ;67
00007a  d3f5              BCC      |L1.104|
                  |L1.124|
;;;70     	  pIn  +=16;
;;;71     	  pOut +=16;
;;;72     	 }
;;;73     }
00007c  b03d              ADD      sp,sp,#0xf4
00007e  bdf0              POP      {r4-r7,pc}
;;;74     
                          ENDP

                  Aes_decrypt PROC
;;;79     **********************************************************************************************************/
;;;80     void Aes_decrypt(u8 LenOfKey, u8 LenOfIn, u8 * pKey, u8 * pIn, u8 * pOut )
000080  b5f0              PUSH     {r4-r7,lr}
;;;81     {
000082  461d              MOV      r5,r3
000084  b0bd              SUB      sp,sp,#0xf4
000086  4613              MOV      r3,r2
;;;82     	 u16 i;
;;;83     	 u16 blk_num;
;;;84     	 u8 roundkey[240]; // 需要为AES 运算申请240 字节的 roundkey 空间
;;;85     	 
;;;86     	 blk_num = LenOfIn / 16;
000088  090f              LSRS     r7,r1,#4
;;;87     
;;;88     	 LK_AesSetKeyDec(LenOfKey,pKey,roundkey);
00008a  466a              MOV      r2,sp
00008c  4619              MOV      r1,r3
00008e  9e42              LDR      r6,[sp,#0x108]
000090  f7fffffe          BL       LK_AesSetKeyDec
;;;89     	 
;;;90     	 for(i=0;i<blk_num;i++)
000094  2400              MOVS     r4,#0
000096  e007              B        |L1.168|
                  |L1.152|
;;;91     	 {
;;;92     	  LK_AesDecode(pIn, pOut);
000098  4631              MOV      r1,r6
00009a  4628              MOV      r0,r5
00009c  f7fffffe          BL       LK_AesDecode
0000a0  1c64              ADDS     r4,r4,#1
0000a2  3510              ADDS     r5,r5,#0x10           ;90
0000a4  b2a4              UXTH     r4,r4                 ;90
0000a6  3610              ADDS     r6,r6,#0x10           ;90
                  |L1.168|
0000a8  42bc              CMP      r4,r7                 ;90
0000aa  d3f5              BCC      |L1.152|
;;;93     	  pIn  +=16;
;;;94     	  pOut +=16;
;;;95     	 }
;;;96     }
0000ac  e7e6              B        |L1.124|
;;;97     
                          ENDP

                  GPIO_IN PROC
;;;98     void GPIO_IN(u8 GPIO_Pin)
0000ae  21f3              MOVS     r1,#0xf3
;;;99     {  
;;;100      int i=GPIO_Pin-1;	
;;;101    	GPIO->GPIODIR &= ~(1<<i);//0是输入
0000b0  0309              LSLS     r1,r1,#12
0000b2  684a              LDR      r2,[r1,#4]
0000b4  2301              MOVS     r3,#1
0000b6  1e40              SUBS     r0,r0,#1
0000b8  4083              LSLS     r3,r3,r0
0000ba  439a              BICS     r2,r2,r3
0000bc  604a              STR      r2,[r1,#4]
;;;102    }
0000be  4770              BX       lr
;;;103    u8 READ_GPIO(u8 GPIO_Pin)
                          ENDP

                  READ_GPIO PROC
0000c0  21f3              MOVS     r1,#0xf3
;;;104    {  
;;;105      int i=GPIO_Pin-1;	
;;;106      return ((u8)(GPIO->GPIODATA>>i)&0x01);
0000c2  0309              LSLS     r1,r1,#12
0000c4  6809              LDR      r1,[r1,#0]
0000c6  1e40              SUBS     r0,r0,#1
0000c8  40c1              LSRS     r1,r1,r0
0000ca  07c8              LSLS     r0,r1,#31
0000cc  0fc0              LSRS     r0,r0,#31
;;;107    }
0000ce  4770              BX       lr
;;;108    
                          ENDP

                  GPIO_OUT PROC
;;;109    void GPIO_OUT(u8 GPIO_Pin)
0000d0  21f3              MOVS     r1,#0xf3
;;;110    {
;;;111      int i=GPIO_Pin-1;  	
;;;112    	GPIO->GPIODIR |= (1<<i);	//1是输出
0000d2  0309              LSLS     r1,r1,#12
0000d4  684a              LDR      r2,[r1,#4]
0000d6  2301              MOVS     r3,#1
0000d8  1e40              SUBS     r0,r0,#1
0000da  4083              LSLS     r3,r3,r0
0000dc  431a              ORRS     r2,r2,r3
0000de  604a              STR      r2,[r1,#4]
;;;113    }
0000e0  4770              BX       lr
;;;114    
                          ENDP

                  GPIO_SetBits PROC
;;;115    void GPIO_SetBits(u8 GPIO_Pin)
0000e2  21f3              MOVS     r1,#0xf3
;;;116    {  
;;;117      int i=GPIO_Pin-1;  		
;;;118    	GPIO->GPIODATA |= (1<<i); // 拉高		
0000e4  0309              LSLS     r1,r1,#12
0000e6  680a              LDR      r2,[r1,#0]
0000e8  2301              MOVS     r3,#1
0000ea  1e40              SUBS     r0,r0,#1
0000ec  4083              LSLS     r3,r3,r0
0000ee  431a              ORRS     r2,r2,r3
0000f0  600a              STR      r2,[r1,#0]
;;;119    }
0000f2  4770              BX       lr
;;;120    
                          ENDP

                  GPIO_ResetBits PROC
;;;121    void GPIO_ResetBits(u8 GPIO_Pin)
0000f4  21f3              MOVS     r1,#0xf3
;;;122    {
;;;123      int i=GPIO_Pin-1;
;;;124    	GPIO->GPIODATA &= ~(1<<i);// 拉低
0000f6  0309              LSLS     r1,r1,#12
0000f8  680a              LDR      r2,[r1,#0]
0000fa  2301              MOVS     r3,#1
0000fc  1e40              SUBS     r0,r0,#1
0000fe  4083              LSLS     r3,r3,r0
000100  439a              BICS     r2,r2,r3
000102  600a              STR      r2,[r1,#0]
;;;125    }
000104  4770              BX       lr
;;;126    
                          ENDP

                  Hash_Digest PROC
;;;131    *********************************************************************************************************/
;;;132    void Hash_Digest(u8 hashType, u16 LenOfMsg, u8 * pMsg, u8 * pDigest)
000106  b5f8              PUSH     {r3-r7,lr}
;;;133    {
000108  461e              MOV      r6,r3
00010a  4617              MOV      r7,r2
00010c  460c              MOV      r4,r1
00010e  4605              MOV      r5,r0
;;;134     	LK_HashInit(hashType);
000110  f7fffffe          BL       LK_HashInit
;;;135    	LK_HashLastUpdate(hashType , pMsg, LenOfMsg );
000114  b2e2              UXTB     r2,r4
000116  4639              MOV      r1,r7
000118  4628              MOV      r0,r5
00011a  f7fffffe          BL       LK_HashLastUpdate
;;;136    	LK_HashGetDigest(hashType, pDigest );
00011e  4631              MOV      r1,r6
000120  4628              MOV      r0,r5
000122  f7fffffe          BL       LK_HashGetDigest
;;;137    }
000126  bdf8              POP      {r3-r7,pc}
;;;138    
                          ENDP

                  Communication_Test PROC
;;;160    ***************************************************************************************************************/
;;;161    void Communication_Test(u8  *in,u8 *out,u8 len)
000128  b510              PUSH     {r4,lr}
;;;162    {
;;;163      u8 i;
;;;164        
;;;165      for(i=0;i < len;i++)
00012a  2300              MOVS     r3,#0
00012c  e004              B        |L1.312|
                  |L1.302|
;;;166       out[i]= ~in[i]; 
00012e  5cc4              LDRB     r4,[r0,r3]
000130  43e4              MVNS     r4,r4
000132  54cc              STRB     r4,[r1,r3]
000134  1c5b              ADDS     r3,r3,#1
000136  b2db              UXTB     r3,r3                 ;165
                  |L1.312|
000138  4293              CMP      r3,r2                 ;165
00013a  d3f8              BCC      |L1.302|
;;;167    			   	
;;;168    }
00013c  bd10              POP      {r4,pc}
;;;169    
                          ENDP

                  Write_Key PROC
;;;182    ****************************************************************************************************************/
;;;183    void Write_Key(u8 *buf)
00013e  b510              PUSH     {r4,lr}
;;;184    {  
;;;185      u16 key_addr;
;;;186      key_addr = ADDR_OF_DES_KEY;
;;;187      LK_WriteNvm(key_addr,buf,buf[0]+1);
000140  7801              LDRB     r1,[r0,#0]
000142  23ff              MOVS     r3,#0xff              ;186
000144  1c49              ADDS     r1,r1,#1
000146  b2ca              UXTB     r2,r1
000148  3301              ADDS     r3,#1                 ;186
00014a  4601              MOV      r1,r0
00014c  4618              MOV      r0,r3
00014e  f7fffffe          BL       LK_WriteNvm
;;;188      return;
;;;189    }
000152  bd10              POP      {r4,pc}
;;;190    
                          ENDP

                  Contrast_Authentication PROC
;;;209    ***************************************************************************************************************/
;;;210    int Contrast_Authentication(u8 *pIn,u8 *pOut)
000154  b530              PUSH     {r4,r5,lr}
;;;211    {
000156  460d              MOV      r5,r1
000158  b099              SUB      sp,sp,#0x64
;;;212    	 u8 i=0;
;;;213    	 u8 RandBuf[0x20];
;;;214    	 u8 CompBuf[0x20];
;;;215    	 u8 KeyBuf[0x20];
;;;216    
;;;217    	 memmove(CompBuf,pIn,0x08);      														// 将加密数据 存放到 CompBuf 数组中
00015a  4601              MOV      r1,r0
00015c  2400              MOVS     r4,#0                 ;212
00015e  2208              MOVS     r2,#8
000160  a809              ADD      r0,sp,#0x24
000162  f7fffffe          BL       __aeabi_memmove
;;;218       LK_GetRandom( RandBuf,0x08);    														// 获取8字节随机数
000166  2108              MOVS     r1,#8
000168  a811              ADD      r0,sp,#0x44
00016a  f7fffffe          BL       LK_GetRandom
;;;219    	 memmove( pOut,RandBuf,0x08);    														// pOut 地址开始存入 8字节随机数
00016e  2208              MOVS     r2,#8
000170  a911              ADD      r1,sp,#0x44
000172  4628              MOV      r0,r5
000174  f7fffffe          BL       __aeabi_memmove
000178  aa11              ADD      r2,sp,#0x44           ;213
00017a  a809              ADD      r0,sp,#0x24           ;214
                  |L1.380|
;;;220       for(i=0;i < 8;i++)
;;;221       {
;;;222            CompBuf[i] ^=RandBuf[i]; 															//随机数与传入数据异或操作
00017c  5d01              LDRB     r1,[r0,r4]
00017e  5d13              LDRB     r3,[r2,r4]
000180  4059              EORS     r1,r1,r3
000182  5501              STRB     r1,[r0,r4]
000184  1c64              ADDS     r4,r4,#1
000186  b2e4              UXTB     r4,r4                 ;220
000188  2c08              CMP      r4,#8                 ;220
00018a  d3f7              BCC      |L1.380|
;;;223    	 }	
;;;224     
;;;225    	 
;;;226      
;;;227    	LK_ReadNvm(ADDR_OF_DES_KEY,KeyBuf,0x11);										//NVM区中读取密钥 //如果KEY 的长度错误,则无法完成加密运算 
00018c  20ff              MOVS     r0,#0xff
00018e  2211              MOVS     r2,#0x11
000190  a901              ADD      r1,sp,#4
000192  3001              ADDS     r0,#1
000194  f7fffffe          BL       LK_ReadNvm
;;;228      if ((KeyBuf[0] != 8) && (KeyBuf[0] != 16 ) )
000198  4668              MOV      r0,sp
00019a  7900              LDRB     r0,[r0,#4]
00019c  2808              CMP      r0,#8
00019e  d004              BEQ      |L1.426|
0001a0  2810              CMP      r0,#0x10
0001a2  d002              BEQ      |L1.426|
;;;229      {  
;;;230    			return 0;
0001a4  2000              MOVS     r0,#0
                  |L1.422|
;;;231      }
;;;232      Des_encrypt(KeyBuf[0],8,KeyBuf+1,CompBuf,pOut+8);  					// pOut+8 地址开始 存放加密的数据
;;;233    
;;;234      return 1;
;;;235    
;;;236    }
0001a6  b019              ADD      sp,sp,#0x64
0001a8  bd30              POP      {r4,r5,pc}
                  |L1.426|
0001aa  3508              ADDS     r5,r5,#8
0001ac  aa01              ADD      r2,sp,#4              ;232
0001ae  ab09              ADD      r3,sp,#0x24           ;232
0001b0  3201              ADDS     r2,#1                 ;232
0001b2  2108              MOVS     r1,#8                 ;232
0001b4  9500              STR      r5,[sp,#0]            ;232
0001b6  f7fffffe          BL       Des_encrypt
0001ba  2001              MOVS     r0,#1                 ;234
0001bc  e7f3              B        |L1.422|
;;;237    
                          ENDP

                  Write_Important_Data PROC
;;;257    ****************************************************************************************************************/
;;;258    void Write_Important_Data(u8  *pIn)
0001be  b510              PUSH     {r4,lr}
;;;259    {
0001c0  4601              MOV      r1,r0
;;;260    	u16 Important_Data_Addr;
;;;261    	
;;;262      Important_Data_Addr = ADDR_OF_DATA ;
0001c2  2000              MOVS     r0,#0
;;;263      LK_WriteNvm(Important_Data_Addr,pIn,8);  														//固定传入参数 8字节 
0001c4  2208              MOVS     r2,#8
0001c6  f7fffffe          BL       LK_WriteNvm
;;;264    }
0001ca  bd10              POP      {r4,pc}
;;;265    
                          ENDP

                  Read_Important_Data PROC
;;;277    ****************************************************************************************************************/
;;;278    int Read_Important_Data(u8  *pIn,u8  *pOut)
0001cc  b570              PUSH     {r4-r6,lr}
;;;279    {
0001ce  460e              MOV      r6,r1
0001d0  b0a2              SUB      sp,sp,#0x88
;;;280    	u8 i=0;
;;;281    	u8 RandBuf_1[0x20];
;;;282    	u8 RandBuf_2[0x20];
;;;283    	u8 ParaBuf[0x20];
;;;284    	u8 KeyBuf[0x20];
;;;285      memmove(RandBuf_1,pIn,0x08); 																		  //将MCU 发来的8字节随机数存储在 RandBuf_1中
0001d2  4601              MOV      r1,r0
0001d4  2400              MOVS     r4,#0                 ;280
0001d6  2208              MOVS     r2,#8
0001d8  a819              ADD      r0,sp,#0x64
0001da  f7fffffe          BL       __aeabi_memmove
;;;286    	
;;;287    	LK_GetRandom(RandBuf_2,0x08);   																  // 获取8字节随机数
0001de  2108              MOVS     r1,#8
0001e0  a809              ADD      r0,sp,#0x24
0001e2  f7fffffe          BL       LK_GetRandom
;;;288      memmove( pOut,RandBuf_2,0x08);                                    // pOut 地址开始存入 8字节随机数
0001e6  2208              MOVS     r2,#8
0001e8  a909              ADD      r1,sp,#0x24
0001ea  4630              MOV      r0,r6
0001ec  f7fffffe          BL       __aeabi_memmove
0001f0  a919              ADD      r1,sp,#0x64           ;281
0001f2  ad09              ADD      r5,sp,#0x24           ;282
                  |L1.500|
;;;289    	
;;;290      for(i=0;i < 8;i++)
;;;291      {
;;;292            RandBuf_2[i] ^=RandBuf_1[i]; 																//随机数与传入随机数做异或操作
0001f4  5d28              LDRB     r0,[r5,r4]
0001f6  5d0a              LDRB     r2,[r1,r4]
0001f8  4050              EORS     r0,r0,r2
0001fa  5528              STRB     r0,[r5,r4]
0001fc  1c64              ADDS     r4,r4,#1
0001fe  b2e4              UXTB     r4,r4                 ;290
000200  2c08              CMP      r4,#8                 ;290
000202  d3f7              BCC      |L1.500|
;;;293    	}	
;;;294      
;;;295      LK_ReadNvm((u16)ADDR_OF_DATA,ParaBuf,8);   										    // 读取 传入的8 字节重要参数
000204  2208              MOVS     r2,#8
000206  a911              ADD      r1,sp,#0x44
000208  2000              MOVS     r0,#0
00020a  f7fffffe          BL       LK_ReadNvm
;;;296    	
;;;297    	for(i=0;i < 8;i++)
00020e  2000              MOVS     r0,#0
000210  a911              ADD      r1,sp,#0x44           ;283
                  |L1.530|
;;;298      {
;;;299            ParaBuf[i] ^=RandBuf_2[i]; 																	//随机数与 总要参数做异或
000212  5c0a              LDRB     r2,[r1,r0]
000214  5c2b              LDRB     r3,[r5,r0]
000216  405a              EORS     r2,r2,r3
000218  540a              STRB     r2,[r1,r0]
00021a  1c40              ADDS     r0,r0,#1
00021c  b2c0              UXTB     r0,r0                 ;297
00021e  2808              CMP      r0,#8                 ;297
000220  d3f7              BCC      |L1.530|
;;;300    	}	
;;;301    
;;;302    	
;;;303    	LK_ReadNvm(ADDR_OF_DES_KEY,KeyBuf,0x11);													//NVM区中读取密钥 //如果KEY 的长度错误,则无法完成加密运算 
000222  20ff              MOVS     r0,#0xff
000224  2211              MOVS     r2,#0x11
000226  a901              ADD      r1,sp,#4
000228  3001              ADDS     r0,#1
00022a  f7fffffe          BL       LK_ReadNvm
;;;304      if ((KeyBuf[0] != 8) && (KeyBuf[0] != 16 ) )
00022e  4668              MOV      r0,sp
000230  7900              LDRB     r0,[r0,#4]
000232  2808              CMP      r0,#8
000234  d004              BEQ      |L1.576|
000236  2810              CMP      r0,#0x10
000238  d002              BEQ      |L1.576|
;;;305      {  
;;;306    			return 0;
00023a  2000              MOVS     r0,#0
                  |L1.572|
;;;307      }
;;;308      Des_encrypt(KeyBuf[0],8,KeyBuf+1,ParaBuf,pOut+8);  								// pOut+8 地址开始 存放加密的数据
;;;309    	
;;;310    	return 1;
;;;311    	
;;;312    }
00023c  b022              ADD      sp,sp,#0x88
00023e  bd70              POP      {r4-r6,pc}
                  |L1.576|
000240  3608              ADDS     r6,r6,#8
000242  aa01              ADD      r2,sp,#4              ;308
000244  ab11              ADD      r3,sp,#0x44           ;308
000246  3201              ADDS     r2,#1                 ;308
000248  2108              MOVS     r1,#8                 ;308
00024a  9600              STR      r6,[sp,#0]            ;308
00024c  f7fffffe          BL       Des_encrypt
000250  2001              MOVS     r0,#1                 ;310
000252  e7f3              B        |L1.572|
;;;313    
                          ENDP

                  Algorithm_Transplantation PROC
;;;346    ***************************************************************************************************************/
;;;347    int Algorithm_Transplantation(u8 *pIn,u8 *pOut)
000254  b538              PUSH     {r3-r5,lr}
;;;348    {
000256  460c              MOV      r4,r1
;;;349    
;;;350    	  float num=0.0;
000258  2100              MOVS     r1,#0
;;;351        if( pIn[0]>=0.0 && pIn[0]<2)
00025a  9100              STR      r1,[sp,#0]
00025c  7800              LDRB     r0,[r0,#0]
00025e  2802              CMP      r0,#2
000260  d202              BCS      |L1.616|
                  |L1.610|
;;;352    		{
;;;353    				num=pIn[0];
000262  f7fffffe          BL       __aeabi_ui2f
000266  e01b              B        |L1.672|
                  |L1.616|
;;;354    		}
;;;355    	  else if( pIn[0]>=2 && pIn[0]<6 )
000268  1e81              SUBS     r1,r0,#2
00026a  2904              CMP      r1,#4
00026c  d202              BCS      |L1.628|
;;;356    		{
;;;357    				num=pIn[0]*pIn[0]+1;
00026e  4340              MULS     r0,r0,r0
000270  1c40              ADDS     r0,r0,#1
000272  e7f6              B        |L1.610|
                  |L1.628|
;;;358    		}
;;;359    	  else if( pIn[0]>=6 && pIn[0]<10)
000274  1f81              SUBS     r1,r0,#6
000276  2904              CMP      r1,#4
000278  d205              BCS      |L1.646|
00027a  1c40              ADDS     r0,r0,#1
;;;360    		{
;;;361    			  num=sqrt(pIn[0]+1);
00027c  f7fffffe          BL       __aeabi_ui2d
000280  f7fffffe          BL       sqrt
000284  e00a              B        |L1.668|
                  |L1.646|
;;;362    		}
;;;363    		else if( pIn[0]>=10 )
000286  280a              CMP      r0,#0xa
000288  d30b              BCC      |L1.674|
00028a  1c40              ADDS     r0,r0,#1
;;;364    		{
;;;365    				num= 1.0/(pIn[0]+1);
00028c  f7fffffe          BL       __aeabi_ui2d
000290  460b              MOV      r3,r1
000292  4602              MOV      r2,r0
000294  2000              MOVS     r0,#0
000296  4906              LDR      r1,|L1.688|
000298  f7fffffe          BL       __aeabi_ddiv
                  |L1.668|
00029c  f7fffffe          BL       __aeabi_d2f
                  |L1.672|
0002a0  9000              STR      r0,[sp,#0]
                  |L1.674|
;;;366    		}
;;;367    		
;;;368    		memmove(pOut,&num,0x04);
0002a2  2204              MOVS     r2,#4
0002a4  4669              MOV      r1,sp
0002a6  4620              MOV      r0,r4
0002a8  f7fffffe          BL       __aeabi_memmove
;;;369    		
;;;370    		return 4;
0002ac  2004              MOVS     r0,#4
;;;371    }
0002ae  bd38              POP      {r3-r5,pc}
;;;372    
                          ENDP

                  |L1.688|
                          DCD      0x3ff00000
